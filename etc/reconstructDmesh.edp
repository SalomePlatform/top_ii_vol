//  run with MPI:  ff-mpirun -np 4 script.edp
// NBPROC 4

load "PETSc"
func Pk = P1;
macro grad(u)[dx(u), dy(u), dz(u)]// // three-dimensional gradient
macro def(u)u//
{
    macro dimension()3// EOM
    include "macro_ddm.idp"
    mesh3 Th;

    mesh3 ThGlobal;
    ThGlobal = cube(getARGV("-global_3d", 20), getARGV("-global_3d", 20), getARGV("-global_3d", 20));
    fespace Ph(ThGlobal, P0);
    Ph part;
    if(mpirank == 0) {
        partitionerSeq(part[], ThGlobal, mpisize);
    }
    partitionerPar(part[], ThGlobal, mpiCommWorld, mpisize);

    Th = trunc(ThGlobal, abs(part - mpirank) < 1.0e-2, renum = 1);
    savemesh(Th,"ffPart2vtest_"+mpirank+".mesh"); 
 
    Th=readmesh3("ffPart2vtest_"+mpirank+".mesh");

    reconstructDmesh(Th)
    fespace Wh(Th, Pk);
    Wh<real> u;
    createPartition(Th, u[], Pk)

    plotMPI(Th, u, Pk, def, real, cmm = "Partition of unity")
    Mat A;
    createMat(Th, A, Pk)

    varf vPb(u, v) = intN(Th)(grad(u)' * grad(v)) + intN(Th)(1e6*(x<.6)*(x>.4)*x*y*v) + on(3, u = 15.0)+ on(1, u = 1.0);
    real[int] rhs = vPb(0, Wh);

    set(A, sparams = "-ksp_view");

    A = vPb(Wh, Wh);
    u[] = A^-1 * rhs; 

    plotMPI(Th, u, Pk, def, real, cmm = "Partition of unity"); 
    int[int] fforder=[1];
    savevtk("vtk.vtu",Th,u,order=fforder);
}
